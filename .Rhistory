premium=payout*pnorm(trigger,mean_theta,sigma_theta)
xnext=map_dbl(sim,~growth(b=b,f=f,theta=.x))
temp<-map_dbl(xnext,~spline(x=xgrid,y=V,xout=.x,method='natural')$y)
pi_df=pi(f=f,b=b,theta=sim)
df<-data.frame(f=f,b=b,theta=sim,trigger=trigger,pi=pi_df,payout=payout,premium=premium,method=ut_mod)
utility<-pmap_dbl(df,ut)
eu=mean(utility+temp*delta,na.rm=TRUE)
#xnext = max(small,f(h,x))
#browser()
return(-eu)
}
DFall = data.frame()
Vnext = vector(mode='numeric',length=sizex)
V = rep(0,length.out=sizex)
pol_converged=vector(mode='numeric',length=sizex) #Harvest Policy function
polnow=vector(mode='numeric',length=sizex)
step=1
error="False"
tol=0.001
while(error=="False"){
t=step
print(t)
#Loop over shocks space
for(i in 1:length(xgrid)){
b=xgrid[i]
guess=0.1
low=.0001
high= 1
output = optim(par=guess,fn=Payoff,lower=low,upper=high,b=b,V=V,sim=sim,method='L-BFGS-B')
fstar = output$par
Vstar = -output$value
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
#browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==400){
print('Maximum number of iterations (400) reached.')
break
}
}
rn_pol_conv<-DFall %>%
filter(time==max(DFall$time)) %>%
group_by(b) %>%
summarize(pol_opt=mean(fstar))
View(rn_pol_conv)
save(rn_pol_conv,file=here::here('data','rn_pol_2_22'))
### Run a forward simulation using the harvest control rules
library(tidyverse)
load(here::here('data','ins_pol_unknown.Rdata'))
load(here::here('data','no_pol_unknown.Rdata'))
load(here::here('data','rn_pol_2_22.Rdata'))
save(rn_pol_conv,file=here::here('data','rn_pol_2_22.Rdata'))
### Run a forward simulation using the harvest control rules
library(tidyverse)
load(here::here('data','ins_pol_unknown.Rdata'))
load(here::here('data','no_pol_unknown.Rdata'))
load(here::here('data','rn_pol_2_22.Rdata'))
# make 30 year random weather draws 500 times
set.seed(42)
rnd_weather <- replicate(500, rnorm(30, 0, 0.5))
#replace any values of rnd_Weather less than -1 with -0.99
rnd_weather[rnd_weather < -.75] <- -0.75
### Parameters
cshape=1.3 #cost shaping parameter
delta=.96
r=0.8
K=1000
small=K/100
p=5
c=250
ut_mod='cara'
a=0.008
insurance=1 #use insurance 1, 0 no insurance
gamma=250
trigger=0
mean_theta=0
sigma_theta=0.5
premium=gamma*pnorm(trigger,mean_theta,sigma_theta)
# define growth, profit, and utility functions
growth = function(b,f,theta)
{
escapement=b*(1+theta)-harvest(f=f,biomass=b,theta = theta)
if(escapement>K){
bnext=K
}else if(escapement<0){
bnext=small
}  else{
bnext = escapement + r*escapement*(1-escapement/K)
}
return(bnext)
}
harvest <- function(f, biomass, theta){
harvest = f * biomass * (1+theta)
return(harvest)
}
pi = function(f,b,theta)
{
profit = (p*harvest(f=f,biomass=b,theta = theta))-(c*(f^cshape))
return(profit)
}
ut<-function(f,b,theta,trigger,pi,payout,premium,method='cara'){
if(theta<trigger){
pi_out<-pi+payout-premium
} else{
pi_out<-pi-premium
}
if(method=='cara'){
out=1-exp(-a*(pi_out))
}else if(method=='log'){
out=log(pi_out+1000)  #Plus 1000 is to make sure we dont have negative values
}else if (method=='rn'){
out=pi_out
} else{
print('Not a valid utility function. Please use cara: for constant absolute risk aversion, log: for log utility, or rn: for risk neutral')
}
return(out)
}
b0=100
final_ut<-rep(NA,500)
final_b<-rep(NA,500)
final_ut_no<-rep(NA,500)
final_b_no<-rep(NA,500)
final_ut_rn<-rep(NA,500)
final_b_rn<-rep(NA,500)
for(j in 1:ncol(rnd_weather)){
# make a data frame to store the results
sim <- data.frame(year = 1:30,
ins_ut = rep(NA, 30),
no_ut = rep(NA, 30),
ins_b= rep(NA, 30),
no_b = rep(NA, 30),
rn_ut = rep(NA, 30),
rn_b = rep(NA, 30))
# set the initial population size
sim$ins_b[1] <- b0
sim$no_b[1] <- b0
sim$rn_b[1] <- b0
f_ins<-spline(x=ins_pol_conv$b,y=ins_pol_conv$pol_opt,xout=sim$ins_b[1])$y
f_no<-spline(x=no_pol_conv$b,y=no_pol_conv$pol_opt,xout=sim$no_b[1])$y
f_rn<-spline(x=rn_pol_conv$b,y=rn_pol_conv$pol_opt,xout=sim$rn_b[1])$y
# get insurance utility
temp_pi<-pi(f_ins,sim$ins_b[1],rnd_weather[1,j])
sim$ins_ut[1]<-ut(f_ins,sim$ins_b[1],rnd_weather[1,j],trigger,temp_pi,gamma,premium,ut_mod)
# get no insurance utility
temp_pi<-pi(f_no,sim$no_b[1],rnd_weather[1,j])
sim$no_ut[1]<-ut(f_no,sim$no_b[1],rnd_weather[1,j],trigger,temp_pi,0,0,ut_mod)
# get risk neutral utility
temp_pi<-pi(f_rn,sim$rn_b[1],rnd_weather[1,j])
sim$rn_ut[1]<-ut(f_rn,sim$rn_b[1],rnd_weather[1,j],trigger,temp_pi,gamma,premium,ut_mod)
# get the next year's population size
sim$ins_b[1] <- growth(sim$ins_b[1],f_ins,rnd_weather[1,j])
sim$no_b[1] <- growth(sim$no_b[1],f_no,rnd_weather[1,j])
sim$rn_b[1] <- growth(sim$rn_b[1],f_rn,rnd_weather[1,j])
# loop over the years
for(i in 2:30){
sim$ins_b[i] <- growth(sim$ins_b[i-1],f_ins,rnd_weather[i,j])
sim$no_b[i] <- growth(sim$no_b[i-1],f_no,rnd_weather[i,j])
sim$rn_b[i] <- growth(sim$rn_b[i-1],f_rn,rnd_weather[i,j])
f_ins<-spline(x=ins_pol_conv$b,y=ins_pol_conv$pol_opt,xout=sim$ins_b[i])$y
f_no<-spline(x=no_pol_conv$b,y=no_pol_conv$pol_opt,xout=sim$no_b[i])$y
f_rn<-spline(x=rn_pol_conv$b,y=rn_pol_conv$pol_opt,xout=sim$rn_b[i])$y
# get insurance utility
temp_pi<-pi(f_ins,sim$ins_b[i],rnd_weather[i,j])
sim$ins_ut[i]<-ut(f_ins,sim$ins_b[i],rnd_weather[i,j],trigger,temp_pi,gamma,premium,ut_mod)
# get no insurance utility
temp_pi<-pi(f_no,sim$no_b[i],rnd_weather[i,j])
sim$no_ut[i]<-ut(f_no,sim$no_b[i],rnd_weather[i,j],trigger,temp_pi,0,0,ut_mod)
# get risk neutral utility
temp_pi<-pi(f_rn,sim$rn_b[i],rnd_weather[i,j])
sim$rn_ut[i]<-ut(f_rn,sim$rn_b[i],rnd_weather[i,j],trigger,temp_pi,gamma,premium,ut_mod)
# get the next year's population size
}
# discount the utilities
sim$ins_ut <- sim$ins_ut * delta^(0:29)
sim$no_ut <- sim$no_ut * delta^(0:29)
sim$rn_ut <- sim$rn_ut * delta^(0:29)
# store the final biomass and summed discounted utilities in storage vec
final_ut[j] <- sum(sim$ins_ut)
final_b[j] <- sim$ins_b[30]
final_ut_no[j] <- sum(sim$no_ut)
final_b_no[j] <- sim$no_b[30]
final_ut_rn[j] <- sum(sim$rn_ut)
final_b_rn[j] <- sim$rn_b[30]
}
df<-data.frame(final_ut, final_b, final_ut_no, final_b_no,final_ut_rn,final_b_rn,sim=1:500,b0=b0) |>
drop_na() |>
pivot_longer(cols=c(final_ut, final_b, final_ut_no, final_b_no), names_to='variable', values_to='value')
df |> filter(variable %in% c('final_b_rn', 'final_b_no')) |>
ggplot(aes(x=value, fill=variable, color=variable)) +
geom_density(aes(y = after_stat(density * length(df$value))),alpha=0.33,linewidth=2.5) +
theme_minimal() +
scale_color_manual(name="",values=c("#003660","#79A540"),guide='none')+
scale_fill_manual(name="",values=c("#003660","#79A540"),labels=c("Insurance","No Insurance"))+
theme_classic()+
theme(legend.text=element_text(size=24))+
theme(legend.title =element_text(size=28))+
theme(axis.text =element_text(size=22))+
theme(axis.title = element_text(size=26))+
labs(title='', x='Final Biomass', y='Density')+
scale_y_continuous(expand = c(0,0),
limits=c(0,2.7))+
guides(fill = guide_legend(byrow=TRUE, override.aes = list(shape = NA, color = NA, fill = c("#003660", "#79A540"))))+
theme(legend.spacing.y = unit(10, "cm"))
View(df)
df<-data.frame(final_ut, final_b, final_ut_no, final_b_no,final_ut_rn,final_b_rn,sim=1:500,b0=b0) |>
drop_na() |>
pivot_longer(cols=c(final_ut, final_b, final_ut_no, final_b_no,final_b_rn,final_ut_rn), names_to='variable', values_to='value')
df |> filter(variable %in% c('final_b_rn', 'final_b_no')) |>
ggplot(aes(x=value, fill=variable, color=variable)) +
geom_density(aes(y = after_stat(density * length(df$value))),alpha=0.33,linewidth=2.5) +
theme_minimal() +
scale_color_manual(name="",values=c("#003660","#79A540"),guide='none')+
scale_fill_manual(name="",values=c("#003660","#79A540"),labels=c("Insurance","No Insurance"))+
theme_classic()+
theme(legend.text=element_text(size=24))+
theme(legend.title =element_text(size=28))+
theme(axis.text =element_text(size=22))+
theme(axis.title = element_text(size=26))+
labs(title='', x='Final Biomass', y='Density')+
scale_y_continuous(expand = c(0,0),
limits=c(0,2.7))+
guides(fill = guide_legend(byrow=TRUE, override.aes = list(shape = NA, color = NA, fill = c("#003660", "#79A540"))))+
theme(legend.spacing.y = unit(10, "cm"))
df |> filter(variable %in% c('final_b_rn', 'final_b_no')) |>
ggplot(aes(x=value, fill=variable, color=variable)) +
geom_density(aes(y = after_stat(density * length(df$value))),alpha=0.33,linewidth=2.5) +
theme_minimal() +
scale_color_manual(name="",values=c("#003660","#79A540"),guide='none')+
scale_fill_manual(name="",values=c("#003660","#79A540"),labels=c("Insurance","No Insurance"))+
theme_classic()+
theme(legend.text=element_text(size=24))+
theme(legend.title =element_text(size=28))+
theme(axis.text =element_text(size=22))+
theme(axis.title = element_text(size=26))+
labs(title='', x='Final Biomass', y='Density')+
scale_y_continuous(expand = c(0,0))+
guides(fill = guide_legend(byrow=TRUE, override.aes = list(shape = NA, color = NA, fill = c("#003660", "#79A540"))))+
theme(legend.spacing.y = unit(10, "cm"))
df |> filter(variable %in% c('final_ut', 'final_ut_no','final_ut_rn')) |>
ggplot(aes(x=value, fill=variable,color=variable)) +
geom_density(alpha=0.33,linewidth=2.5) +
theme_minimal() +
scale_color_manual(name="",values=c("#003660","#79A540","red"),guide='none')+
scale_fill_manual(name="",values=c("#003660","#79A540","red"),labels=c("Insurance","No Insurance","RN"))+
theme_classic()+
theme(legend.text=element_text(size=24))+
theme(legend.title =element_text(size=28))+
theme(axis.text =element_text(size=22))+
theme(axis.title = element_text(size=26))+
labs(title='', x='Sum of discounted utility', y='Density')+
scale_y_continuous(expand = c(0,0))+
guides(fill = guide_legend(byrow=TRUE, override.aes = list(shape = NA, color = NA, fill = c("#003660", "#79A540"))))+
theme(legend.spacing.y = unit(10, "cm"))
df |> filter(variable %in% c('final_ut', 'final_ut_no','final_ut_rn')) |>
ggplot(aes(x=value, fill=variable,color=variable)) +
geom_density(alpha=0.33,linewidth=2.5) +
theme_minimal() +
scale_color_manual(name="",values=c("#003660","#79A540","red"),guide='none')+
scale_fill_manual(name="",values=c("#003660","#79A540","red"),labels=c("Insurance","No Insurance","RN"))+
theme_classic()+
theme(legend.text=element_text(size=24))+
theme(legend.title =element_text(size=28))+
theme(axis.text =element_text(size=22))+
theme(axis.title = element_text(size=26))+
labs(title='', x='Sum of discounted utility', y='Density')+
scale_y_continuous(expand = c(0,0))+
guides(fill = guide_legend(byrow=TRUE, override.aes = list(shape = NA, color = NA, fill = c("#003660", "#79A540","red"))))+
theme(legend.spacing.y = unit(10, "cm"))
#### Shun-Chen idea of first best idea knowing the state variables
library(tidyverse)
sizex = 200 #size of the state grid
sizez = 4  #size of the shock grid
T=50 #time horizon for backward induction
cshape=1.3 #cost shaping parameter
delta=.96
r=0.8
K=1000
small=K/100
p=5
c=250
a=0.008
#Environmental parameters
mean_theta=0
sigma_theta=0.2
#### HCR control ####
hcr="two"
#### Payouts and Premiums parameters ####
insurance=1 #use insurance 1, 0 no insurance
gamma=250
coverage=0
findNearest<-function(x,y){
index<-which.min(abs(x-y))
return(index)
}
#### Set up state grid ####
xgrid = seq(small,K,length.out=sizex)
#### Set up shock grid ####
#eps_list<-c(-.1,0)
#theta_list<-c(.5,-.1)
#d=c(theta_list,eps_list)
#z_list=split(d,ceiling(seq_along(d)/2))
#z_grid=c(0.4,0.6)
n_z=33
n_sims=100000
set.seed(42)
#Get distribution and bins of
theta_raw<-rnorm(n_sims,mean=mean_theta,sd=sigma_theta)
theta_dist<-theta_raw[which(theta_raw>-1)]
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),max(theta_dist),l=n_z+1))
library(tidyverse)
sizex = 50 #size of the state grid
sizez = 4  #size of the shock grid
T=50 #time horizon for backward induction
cshape=1.3 #cost shaping parameter
delta=.96
r=0.8
K=1000
small=K/100
p=5
c=250
ut_mod='rn'
a=0.008 #risk aversion
#Environmental parameters
mean_theta=0
sigma_theta=0.5
set.seed(42)
sim<-rnorm(1000,mean=mean_theta,sd=sigma_theta)
sim<-sim[which(sim>=-1)]
#### HCR control ####
hcr="two"
#### Payouts and Premiums parameters ####
insurance=1 #use insurance 1, 0 no insurance
gamma=1
trigger=0
premium=gamma*pnorm(trigger,mean_theta,sigma_theta)
library(tidyverse)
sizex = 50 #size of the state grid
sizez = 4  #size of the shock grid
T=50 #time horizon for backward induction
cshape=1.3 #cost shaping parameter
delta=.96
r=0.8
K=1000
small=K/100
p=5
c=250
ut_mod='rn'
a=0.008 #risk aversion
#Environmental parameters
mean_theta=0
sigma_theta=0.5
set.seed(42)
sim<-rnorm(1000,mean=mean_theta,sd=sigma_theta)
sim<-sim[which(sim>=-1)]
#### HCR control ####
hcr="two"
#### Payouts and Premiums parameters ####
insurance=1 #use insurance 1, 0 no insurance
gamma=1
trigger=0
premium=gamma*pnorm(trigger,mean_theta,sigma_theta)
n_sims
zgrid = seq(-3*sigma_theta,3*sigma_theta,length.out=sizez)
sizez = 10  #size of the shock grid
zgrid = seq(-3*sigma_theta,3*sigma_theta,length.out=sizez)
sigma_theta
n_z=33
n_sims=100000
set.seed(42)
#Get distribution and bins of
theta_raw<-rnorm(n_sims,mean=mean_theta,sd=sigma_theta)
theta_dist<-theta_raw[which(theta_raw>-1)]
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),max(theta_dist),l=n_z+1))
## Make bins classification
bins=theta_dist
for(k in 2:length(thetahist$breaks)){
index=which(theta_dist>thetahist$breaks[k-1]&theta_dist<=thetahist$breaks[k])
bins[index]=k-1
}
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),max(theta_dist),l=n_z+1))
n_z=13
n_sims=100000
set.seed(42)
#Get distribution and bins of
theta_raw<-rnorm(n_sims,mean=mean_theta,sd=sigma_theta)
theta_dist<-theta_raw[which(theta_raw>-1)]
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),
max(theta_dist),
l=n_z+1))
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),
max(theta_dist),
l=n_z+1))
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),
max(theta_dist),
l=n_z+1))
dev.off()
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),
max(theta_dist),
l=n_z+1))
par(mar=c(1,1,1,1))
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),
max(theta_dist),
l=n_z+1))
n_z=33
par(mar=c(1,1,1,1))
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),
max(theta_dist),
l=n_z+1))
## Make bins classification
bins=theta_dist
for(k in 2:length(thetahist$breaks)){
index=which(theta_dist>thetahist$breaks[k-1]&theta_dist<=thetahist$breaks[k])
bins[index]=k-1
}
theta_df<-data.frame(theta_dist=theta_dist,bins=bins)
means<- theta_df %>%
group_by(bins) %>%
summarize(mean=mean(theta_dist))
#elminate first observation
means=means[-1,]
theta_prop=thetahist$counts/n_sims
theta_val=means$mean
theta_val
theta_prop
theta_dist<-theta_raw[which(theta_raw>-1 & theta_raw<2)]
par(mar=c(1,1,1,1))
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),
max(theta_dist),
l=n_z+1))
## Make bins classification
bins=theta_dist
for(k in 2:length(thetahist$breaks)){
index=which(theta_dist>thetahist$breaks[k-1]&theta_dist<=thetahist$breaks[k])
bins[index]=k-1
}
theta_df<-data.frame(theta_dist=theta_dist,bins=bins)
theta_df<-data.frame(theta_dist=theta_dist,bins=bins)
means<- theta_df %>%
group_by(bins) %>%
summarize(mean=mean(theta_dist))
#elminate first observation
means=means[-1,]
theta_prop=thetahist$counts/n_sims
theta_val=means$mean
sum(theta_prop)
theta_prop=thetahist$counts/nrow(theta_dist)
theta_val=means$mean
sum(theta_prop)
nrow(theta_dist)
length(theta_dist)
theta_prop=thetahist$counts/length(theta_dist)
theta_val=means$mean
sum(theta_prop)
# Use distribution to get insurance parameters
trigger_index=findNearest(coverage,theta_val)
trigger=theta_val[trigger_index]
trigger_prop=sum(theta_prop[1:trigger_index])
payout<-max(trigger-theta_val,0)
payout<-map_dbl(theta_val,~max(trigger-.x,0))
tail(payout)
payout<-map_dbl(theta_val,~max(trigger-.x,0))*gamma*theta_prop
payout<-map_dbl(theta_val,~max(trigger-.x,0))*gamma
mean(payout)
payout[12]
payout[11]
payout[13]
payout[4]
payout<-map_dbl(theta_val,~max(trigger-.x,0))*gamma*theta_prop
payout[11]
mean(payout)
pmap_dbl(theta_raw,~max(0-.x),0)->temp
theta_raw[which(theta_raw>0)]<-0
mean(theta_raw)
#Get distribution and bins of
theta_raw<-rnorm(n_sims,mean=mean_theta,sd=sigma_theta)
theta_dist<-theta_raw[which(theta_raw>-1 & theta_raw<2)]
burn<-vector(mode="numeric",length=length(theta_dist)
)
burn[which(theta_dist>0)]<-0
burn<-theta_dist
burn[which(theta_dist>0)]<-0
mean(burn)
burn<-theta_dist |> as.list()
burn2<-pmap_dbl(burn,max(0-.x),0)
burn2<-pmap_dbl(burn,~max(0-.x),0)
burn[[1]]
burn[[3]]
burn[[1111]]
burn2<-pmap_dbl(burn,~max(0-.x,0))
burn2<-pmap_dbl(burn,~ifelse(.x>0,0,.x))
burn2
burn2<-map_dbl(burn,~max(0-.x,0))
mean(burn2)
burn2<-map_dbl(burn,~gamma*max(0-.x,0))
mean(burn2)
gamma=5
burn2<-map_dbl(burn,~gamma*max(0-.x,0))
mean(burn2)
