vfi_post_out<-pmap(param_grid,vfi_post_fcn)
source(here::here("scripts","fcn","harvest.R"))
source(here::here("scripts","fcn","growth.R"))
source(here::here("scripts","fcn","pi.R"))
source(here::here("scripts","fcn","Payoff_post.R"))
source(here::here("scripts","fcn","Payoff_pre.R"))
source(here::here("scripts","fcn","ut_post.R"))
source(here::here("scripts","fcn","vfi_post_fcn.R"))
source(here::here("scripts","fcn","vfi_pre_fcn.R"))
source(here::here("scripts","fcn","ut.R"))
findNearest<-function(x,y){
index<-which.min(abs(x-y))
return(index)
}
# Set up parameters
param_grid<-expand_grid(sizex=50,n_z=13,cshape=1.3,delta=0.96,r=0.8,K=1000,p=5,c=250,mean_theta=0,sigma_theta=c(0.2,0.5),gamma=seq(0,1000,by=250),coverage=0,ut_par=c(paste0("4","_","power"))) |>
separate(ut_par,into=c("a","ut_mod"),sep="_") |>
mutate(a=as.numeric(a))
vfi_post_out<-pmap(param_grid,vfi_post_fcn)
post_df<-bind_rows(vfi_post_out)
sig_choice<-unique(post_df$parameters$sigma_theta)[1]
## Get realized theta_prop for post evaluation
mean_theta=0
sigma_theta=sig_choice
n_z=13
n_sims=10000
set.seed(42)
#Get distribution and bins of
theta_raw<-rnorm(n_sims,mean=mean_theta,sd=sigma_theta)
theta_dist<-theta_raw[which(theta_raw>-1)]
thetahist<-hist(theta_dist,breaks=seq(min(theta_dist),max(theta_dist),l=n_z+1),plot=FALSE)
## Make bins classification
bins=theta_dist
for(k in 2:length(thetahist$breaks)){
index=which(theta_dist>thetahist$breaks[k-1]&theta_dist<=thetahist$breaks[k])
bins[index]=k-1
}
theta_df<-data.frame(theta_dist=theta_dist,bins=bins)
means<- theta_df |>
group_by(bins) |>
summarize(mean=mean(theta_dist))
#elminate first observation
theta_prop=thetahist$counts/n_sims
theta_val=means$mean
# Summarize best converged gamma for each type of model
summary_post<-post_df |>
group_by(parameters$gamma,parameters$ut_mod,conv$b,parameters$sigma_theta) |>
summarize(mean=weighted.mean(conv$Vstar,theta_prop)) |>
ungroup() |>
rename(gamma="parameters$gamma",
ut_mod="parameters$ut_mod",
b="conv$b",
mean=mean) |>
group_by(gamma,ut_mod) |>
summarize(v=mean(mean)) |>
group_by(ut_mod) |>
slice_max(v)
policy_post<-post_df |>
filter(parameters$gamma==250 & parameters$ut_mod=='power' & parameters$sigma_theta==sig_choice)
policy_post_noi<-post_df |>
filter(parameters$gamma==0 & parameters$ut_mod=='power' & parameters$sigma_theta==sig_choice)
# diverging palette
pal_fun <- scales::col_numeric(
palette = c("red", "grey80", "blue"),
domain  = range(theta_val)
)
# named vector for scale_color_manual
cols <- setNames(pal_fun(theta_val), levels(as.factor(theta_val)))
trig<-unique(policy_post$parameters$trigger)
trig_index<-which(theta_val==trig)
two_line_noi<-policy_post_noi %>%
mutate(pay=ifelse(conv$theta>trig,'no','yes')) |>
group_by(conv$b,pay) %>%
mutate(custom_weight=case_when(
pay=="yes"~theta_prop[1:trig_index][row_number()],
pay=="no"~theta_prop[(trig_index+1):13][row_number()]
)) |>
summarize(fstar=weighted.mean(conv$fstar,w=custom_weight)) |>
ungroup() |>
mutate(ins='No Insurance') |>
rename(b='conv$b')
two_line_i<-policy_post |>
mutate(pay=ifelse(conv$theta>trig,'no','yes')) |>
group_by(conv$b,pay) %>%
mutate(custom_weight=case_when(
pay=="yes"~theta_prop[1:trig_index][row_number()],
pay=="no"~theta_prop[(trig_index+1):13][row_number()]
)) |>
summarize(fstar=weighted.mean(conv$fstar,w=custom_weight,na.rm=TRUE)) |>
ungroup() |>
mutate(ins='Insurance') |>
rename(b='conv$b')
rbind(two_line_noi,two_line_i) |>
ggplot(aes(x=b,y=fstar,color=pay))+
geom_line(aes(linetype = ins),linewidth=1.5)+
ylim(0,0.5)+
scale_color_manual(name='Environmental\nShock',values=c('no'='#047C90','yes'='#78A540'),labels=c('yes'='Negative Shock','no'='Positive Shock'))+
theme_minimal()+
labs(title=paste0('Post','- ','Risk Aversion:',policy_post$parameters$ut_mod[1],' ','Sigma:',sig_choice))
save(file=here::here("data","vfi_post_out_insurance_1-20-26.RData"),vfi_post_out)
source(here::here("scripts","fcn","harvest.R"))
source(here::here("scripts","fcn","growth.R"))
source(here::here("scripts","fcn","pi.R"))
source(here::here("scripts","fcn","Payoff_post.R"))
source(here::here("scripts","fcn","Payoff_pre.R"))
source(here::here("scripts","fcn","ut_post.R"))
source(here::here("scripts","fcn","vfi_post_fcn.R"))
source(here::here("scripts","fcn","vfi_pre_fcn.R"))
source(here::here("scripts","fcn","ut.R"))
findNearest<-function(x,y){
index<-which.min(abs(x-y))
return(index)
}
vfi_pre_out<-pmap(param_grid,vfi_pre_fcn)
save(file=here::here("data","vfi_pre_out_insurance_1-19-26.RData"),vfi_pre_out)
pre_df<-bind_rows(vfi_pre_out)
policy_pre<-pre_df |>
filter(parameters$gamma==250 & parameters$ut_mod=='power' & parameters$sigma_theta==sig_choice)
policy_pre_noi<-pre_df |>
filter(parameters$gamma==0 & parameters$ut_mod=='power' & parameters$sigma_theta==sig_choice)
p_noi_df<-policy_pre_noi |>
mutate(ins='No Insurance')
p_df<-policy_pre |>
mutate(ins="Insurance")
rbind(p_noi_df,p_df) |>
ggplot(aes(x=conv$b,y=conv$fstar,linetype=ins))+
geom_line(linewidth=1.5)+
ylim(0,0.5)+
theme_minimal()+
labs(title=paste0('Pre','- ','Risk Aversion:',policy_post$parameters$ut_mod[1],' ','Sigma:',sig_choice))
source("~/manager-ibi/scripts/fcn/Payoff_pre.R")
Payoff_pre(f=0.1,b=500,V=rep(0,length.out=50),r=0.8,K=1000,delta=0.96,ra=4,ut_mod='power',xgrid=seq(10,1000,length.out=50,p=5,c=250,cshape=1.3,trigger=0,premium=50,gamma=100,sim=sim)
Payoff_pre(f=0.1,b=500,V=rep(0,length.out=50),r=0.8,K=1000,delta=0.96,ra=4,ut_mod='power',xgrid=seq(10,1000,length.out=50),p=5,c=250,cshape=1.3,trigger=0,premium=50,gamma=100,sim=sim)
Payoff_pre(f=0.1,b=500,V=rep(0,length.out=50),r=0.8,K=1000,delta=0.96,ra=4,ut_mod='power',xgrid=seq(10,1000,length.out=50),p=5,c=250,cshape=1.3,trigger=0,premium=50,gamma=100,sim=sim)
sim<-rnorm(1000,mean=mean_theta,sd=sigma_theta)
sim<-sim[which(sim>=-1)]
Payoff_pre(f=0.1,b=500,V=rep(0,length.out=50),r=0.8,K=1000,delta=0.96,ra=4,ut_mod='power',xgrid=seq(10,1000,length.out=50),p=5,c=250,cshape=1.3,trigger=0,premium=50,gamma=100,sim=sim)
Payoff_pre(f=0.5,b=500,V=rep(0,length.out=50),r=0.8,K=1000,delta=0.96,ra=4,ut_mod='power',xgrid=seq(10,1000,length.out=50),p=5,c=250,cshape=1.3,trigger=0,premium=50,gamma=100,sim=sim)
Payoff_pre(f=0.1,b=500,V=rep(0,length.out=50),r=0.8,K=1000,delta=0.96,ra=4,ut_mod='power',xgrid=seq(10,1000,length.out=50),p=5,c=250,cshape=1.3,trigger=0,premium=50,gamma=100,sim=sim)
Payoff_pre(f=0.11,b=500,V=rep(0,length.out=50),r=0.8,K=1000,delta=0.96,ra=4,ut_mod='power',xgrid=seq(10,1000,length.out=50),p=5,c=250,cshape=1.3,trigger=0,premium=50,gamma=100,sim=sim)
vfi_pre_fcn<-function(sizex,n_z,cshape,delta,
r,K,p,c,a,
mean_theta,sigma_theta,
gamma,coverage,
ut_mod){
small=K/100
set.seed(42)
sim<-rnorm(1000,mean=mean_theta,sd=sigma_theta)
sim<-sim[which(sim>=-1)]
trigger=coverage
premium=gamma*pnorm(trigger,mean_theta,sigma_theta)
#### Set up state grid ####
xgrid = seq(small,K,length.out=sizex)
DFall = data.frame()
Vnext = vector(mode='numeric',length=sizex)
V = rep(0,length.out=sizex)
pol_converged=vector(mode='numeric',length=sizex) #Harvest Policy function
polnow=vector(mode='numeric',length=sizex)
step=1
error="False"
tol=0.0001
options=list("algorithm"="NLOPT_LN_COBYLA",xtol_rel=1e-06)
while(error=="False"){
t=step
print(t)
#Loop over shocks space
browser()
for(i in 1:length(xgrid)){
b=xgrid[i]
guess=0.1
low=.0001
high= 1
output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
#output = optim(par=guess,fn=Payoff_pre,lower=low,upper=high,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma,method='L-BFGS-B')
fstar = output$par
Vstar = -output$value
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
#browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==400){
print('Maximum number of iterations (400) reached.')
break
}
}
conv<-DFall |>
filter(time==max(DFall$time)) |>
select(-time)
parameters<-data.frame(
r=r,
K=K,
small=small,
p=p,
c=c,
a=a,
delta=delta,
cshape=cshape,
mean_theta=mean_theta,
sigma_theta=sigma_theta,
gamma=gamma,
coverage=coverage,
premium=premium,
trigger=trigger,
ut_mod=ut_mod
)
policy<-list(conv=conv,parameters=parameters)
return(policy)
}
vfi_pre_out<-pmap(param_grid,vfi_pre_fcn)
mean(sim)
b=xgrid[1]
output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
guess=0.1
output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
#output = optim(par=guess,fn=Payoff_pre,lower=low,upper=high,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma,method='L-BFGS-B')
fstar = output$par
Vstar = -output$value
output$x0
output$objective
output$solution
for(i in 1:length(xgrid)){
b=xgrid[i]
guess=0.1
low=.0001
high= 1
output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
#output = optim(par=guess,fn=Payoff_pre,lower=low,upper=high,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma,method='L-BFGS-B')
fstar = output$solution
Vstar = -output$objective
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
vfi_pre_fcn<-function(sizex,n_z,cshape,delta,
r,K,p,c,a,
mean_theta,sigma_theta,
gamma,coverage,
ut_mod){
small=K/100
set.seed(42)
sim<-rnorm(1000,mean=mean_theta,sd=sigma_theta)
sim<-sim[which(sim>=-1)]
trigger=coverage
premium=gamma*pnorm(trigger,mean_theta,sigma_theta)
#### Set up state grid ####
xgrid = seq(small,K,length.out=sizex)
DFall = data.frame()
Vnext = vector(mode='numeric',length=sizex)
V = rep(0,length.out=sizex)
pol_converged=vector(mode='numeric',length=sizex) #Harvest Policy function
polnow=vector(mode='numeric',length=sizex)
step=1
error="False"
tol=0.0001
options=list("algorithm"="NLOPT_LN_COBYLA",xtol_rel=1e-06)
while(error=="False"){
t=step
print(t)
#Loop over shocks space
browser()
for(i in 1:length(xgrid)){
b=xgrid[i]
guess=0.1
low=.0001
high= 1
output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
#output = optim(par=guess,fn=Payoff_pre,lower=low,upper=high,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma,method='L-BFGS-B')
fstar = output$solution
Vstar = -output$objective
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
#browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==400){
print('Maximum number of iterations (400) reached.')
break
}
}
conv<-DFall |>
filter(time==max(DFall$time)) |>
select(-time)
parameters<-data.frame(
r=r,
K=K,
small=small,
p=p,
c=c,
a=a,
delta=delta,
cshape=cshape,
mean_theta=mean_theta,
sigma_theta=sigma_theta,
gamma=gamma,
coverage=coverage,
premium=premium,
trigger=trigger,
ut_mod=ut_mod
)
policy<-list(conv=conv,parameters=parameters)
return(policy)
}
vfi_pre_out<-pmap(param_grid,vfi_pre_fcn)
polnow
ponow
polnow
vfi_pre_fcn<-function(sizex,n_z,cshape,delta,
r,K,p,c,a,
mean_theta,sigma_theta,
gamma,coverage,
ut_mod){
small=K/100
set.seed(42)
sim<-rnorm(1000,mean=mean_theta,sd=sigma_theta)
sim<-sim[which(sim>=-1)]
trigger=coverage
premium=gamma*pnorm(trigger,mean_theta,sigma_theta)
#### Set up state grid ####
xgrid = seq(small,K,length.out=sizex)
DFall = data.frame()
Vnext = vector(mode='numeric',length=sizex)
V = rep(0,length.out=sizex)
pol_converged=vector(mode='numeric',length=sizex) #Harvest Policy function
polnow=vector(mode='numeric',length=sizex)
step=1
error="False"
tol=0.0001
options=list("algorithm"="NLOPT_LN_COBYLA",xtol_rel=1e-06)
while(error=="False"){
t=step
print(t)
#Loop over shocks space
browser()
for(i in 1:length(xgrid)){
b=xgrid[i]
guess=0.1
output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
#output = optim(par=guess,fn=Payoff_pre,lower=low,upper=high,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma,method='L-BFGS-B')
fstar = output$solution
Vstar = -output$objective
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
#browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==400){
print('Maximum number of iterations (400) reached.')
break
}
}
conv<-DFall |>
filter(time==max(DFall$time)) |>
select(-time)
parameters<-data.frame(
r=r,
K=K,
small=small,
p=p,
c=c,
a=a,
delta=delta,
cshape=cshape,
mean_theta=mean_theta,
sigma_theta=sigma_theta,
gamma=gamma,
coverage=coverage,
premium=premium,
trigger=trigger,
ut_mod=ut_mod
)
policy<-list(conv=conv,parameters=parameters)
return(policy)
}
vfi_pre_out<-pmap(param_grid,vfi_pre_fcn)
vfi_pre_fcn<-function(sizex,n_z,cshape,delta,
r,K,p,c,a,
mean_theta,sigma_theta,
gamma,coverage,
ut_mod){
small=K/100
set.seed(42)
sim<-rnorm(1000,mean=mean_theta,sd=sigma_theta)
sim<-sim[which(sim>=-1)]
trigger=coverage
premium=gamma*pnorm(trigger,mean_theta,sigma_theta)
#### Set up state grid ####
xgrid = seq(small,K,length.out=sizex)
DFall = data.frame()
Vnext = vector(mode='numeric',length=sizex)
V = rep(0,length.out=sizex)
pol_converged=vector(mode='numeric',length=sizex) #Harvest Policy function
polnow=vector(mode='numeric',length=sizex)
step=1
error="False"
tol=0.0001
options=list("algorithm"="NLOPT_LN_COBYLA",xtol_rel=1e-06)
while(error=="False"){
t=step
print(t)
#Loop over shocks space
for(i in 1:length(xgrid)){
b=xgrid[i]
guess=0.1
output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
#output = optim(par=guess,fn=Payoff_pre,lower=low,upper=high,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma,method='L-BFGS-B')
fstar = output$solution
Vstar = -output$objective
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
#browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==400){
print('Maximum number of iterations (400) reached.')
break
}
}
conv<-DFall |>
filter(time==max(DFall$time)) |>
select(-time)
parameters<-data.frame(
r=r,
K=K,
small=small,
p=p,
c=c,
a=a,
delta=delta,
cshape=cshape,
mean_theta=mean_theta,
sigma_theta=sigma_theta,
gamma=gamma,
coverage=coverage,
premium=premium,
trigger=trigger,
ut_mod=ut_mod
)
policy<-list(conv=conv,parameters=parameters)
return(policy)
}
vfi_pre_out<-pmap(param_grid,vfi_pre_fcn)
save(file=here::here("data","vfi_pre_out_insurance_1-19-26.RData"),vfi_pre_out)
pre_df<-bind_rows(vfi_pre_out)
View(pre_df)
policy_pre<-pre_df |>
filter(parameters$gamma==250 & parameters$ut_mod=='power' & parameters$sigma_theta==sig_choice)
policy_pre_noi<-pre_df |>
filter(parameters$gamma==0 & parameters$ut_mod=='power' & parameters$sigma_theta==sig_choice)
p_noi_df<-policy_pre_noi |>
mutate(ins='No Insurance')
p_df<-policy_pre |>
mutate(ins="Insurance")
rbind(p_noi_df,p_df) |>
ggplot(aes(x=conv$b,y=conv$fstar,linetype=ins))+
geom_line(linewidth=1.5)+
ylim(0,0.5)+
theme_minimal()+
labs(title=paste0('Pre','- ','Risk Aversion:',policy_post$parameters$ut_mod[1],' ','Sigma:',sig_choice))
