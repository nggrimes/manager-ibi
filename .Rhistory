t=step
#Loop over shocks space
for(i in 1:n_biomass){
b=biomass_grid[i]
guess=b/10
#output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
output = optim(par=guess,
fn=objective_fcn,
lower=0.00001,
upper=b,
b=b,
V_now=V,
pay_vec=pay,
premium=premium,
method='Brent')
#output = optim(par=guess,fn=objective_fcn,lower=0.00001,upper=K,b=b,V_now=V,pay_vec=pay,premium=premium,method='L-BFGS-B')
fstar = output$par
Vstar = -output$val
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
print(error_vec)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==200){
print('Maximum number of iterations (400) reached.')
break
}
}
utility <- function(c, gamma,boost=100,mod='power') {
c <- c+boost  # Ensure positive
if(mod=='cara'){
ut<-(1-exp((-gamma*c)))/gamma
return(ut)
}
else if (gamma == 1) {
return(log(c))
} else {
return((c^(1 - gamma) - 1) / (1 - gamma))
}
}
DFall = data.frame()
Vnext = vector(mode='numeric',length=n_biomass)
V = rep(0,length.out=n_biomass)
pol_converged=vector(mode='numeric',length=n_biomass) #Harvest Policy function
polnow=vector(mode='numeric',length=n_biomass)
step=1
error="False"
tol=0.01
while(error=="False"){
t=step
#Loop over shocks space
for(i in 1:n_biomass){
b=biomass_grid[i]
guess=b/10
#output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
output = optim(par=guess,
fn=objective_fcn,
lower=0.00001,
upper=b,
b=b,
V_now=V,
pay_vec=pay,
premium=premium,
method='Brent')
#output = optim(par=guess,fn=objective_fcn,lower=0.00001,upper=K,b=b,V_now=V,pay_vec=pay,premium=premium,method='L-BFGS-B')
fstar = output$par
Vstar = -output$val
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
print(error_vec)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==200){
print('Maximum number of iterations (400) reached.')
break
}
}
utility <- function(c, gamma,boost=100,mod='power') {
c <- c+boost  # Ensure positive
if(mod=='cara'){
ut<-(1-exp(-gamma*c))/gamma
return(ut)
}
else if (gamma == 1) {
return(log(c))
} else {
return((c^(1 - gamma) - 1) / (1 - gamma))
}
}
DFall = data.frame()
Vnext = vector(mode='numeric',length=n_biomass)
V = rep(0,length.out=n_biomass)
pol_converged=vector(mode='numeric',length=n_biomass) #Harvest Policy function
polnow=vector(mode='numeric',length=n_biomass)
step=1
error="False"
tol=0.01
while(error=="False"){
t=step
#Loop over shocks space
for(i in 1:n_biomass){
b=biomass_grid[i]
guess=b/10
#output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
output = optim(par=guess,
fn=objective_fcn,
lower=0.00001,
upper=b,
b=b,
V_now=V,
pay_vec=pay,
premium=premium,
method='Brent')
#output = optim(par=guess,fn=objective_fcn,lower=0.00001,upper=K,b=b,V_now=V,pay_vec=pay,premium=premium,method='L-BFGS-B')
fstar = output$par
Vstar = -output$val
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
print(error_vec)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==200){
print('Maximum number of iterations (400) reached.')
break
}
}
gamma
gamma <- 0.15          # Risk aversion (CRRA utility)
DFall = data.frame()
Vnext = vector(mode='numeric',length=n_biomass)
V = rep(0,length.out=n_biomass)
pol_converged=vector(mode='numeric',length=n_biomass) #Harvest Policy function
polnow=vector(mode='numeric',length=n_biomass)
step=1
error="False"
tol=0.01
while(error=="False"){
t=step
#Loop over shocks space
for(i in 1:n_biomass){
b=biomass_grid[i]
guess=b/10
#output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
output = optim(par=guess,
fn=objective_fcn,
lower=0.00001,
upper=b,
b=b,
V_now=V,
pay_vec=pay,
premium=premium,
method='Brent')
#output = optim(par=guess,fn=objective_fcn,lower=0.00001,upper=K,b=b,V_now=V,pay_vec=pay,premium=premium,method='L-BFGS-B')
fstar = output$par
Vstar = -output$val
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
print(error_vec)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==200){
print('Maximum number of iterations (400) reached.')
break
}
}
polnow
biomass_grid
V
Vnext
polnow
Vnext
V
quota=99
b
obj<-optim(par=0.1,
fn=ut_max,
biomass=b,
quota=quota,
pay=pay_vec,
premium=premium,
method="L-BFGS-B",
lower=0,
upper=effort_max)
obj<-optim(par=0.1,
fn=ut_max,
biomass=b,
quota=quota,
pay=pay,
premium=premium,
method="L-BFGS-B",
lower=0,
upper=effort_max)
obj$par
obj$value
effort_choice<-obj$par
e_harvest<-map_dbl(.x=w_grid,
.f=~harvest_function(effort=effort_choice,
biomass=b,
quota=quota,
shock=.x))
e_harvest
w_grid
esc<-map2_dbl(.x=e_harvest,.y=w_grid,~max((1+.y)*b-.x,biomass_min))
escp
esc
xnext<-map_dbl(esc,~growth(.x))
xnext
temp<-map_dbl(xnext,~spline(x=biomass_grid,y=V_now,xout=.x,method='natural')$y)
temp<-map_dbl(xnext,~spline(x=biomass_grid,y=V,xout=.x,method='natural')$y)
temp
sum(temp*w_probs)
pay<-pay_vec
pi<-e_harvest-c_cost*effort_choice^2+pay-premium
e_ut<-map_dbl(.x=pi,
.f=~utility(c=.x,gamma=gamma,boost=0,mod='cara'))*w_probs
e_ut
sum(w_probs*e_ut)
(sum(e_harvest*w_probs)+beta*sum(temp*w_probs))
((1-alpha)*sum(e_ut)+beta*sum(temp*w_probs))
(1-alpha)*sum(e_ut)
e_ut
q
# Max functions
ut_max<-function(effort,biomass,quota,pay,premium){
e_harvest<-map_dbl(.x=w_grid,
.f=~harvest_function(effort=effort,
biomass=biomass,
quota=quota,
shock=.x))
pi<-e_harvest-c_cost*effort^2+pay-premium
e_ut<-map_dbl(.x=pi,
.f=~utility(c=.x,gamma=gamma,boost=0,mod='cara'))*w_probs
return(-sum(e_ut*w_probs))
}
objective_fcn<-function(choice,b,V_now,pay_vec,premium){
quota<-choice[1]
obj<-optim(par=0.1,
fn=ut_max,
biomass=b,
quota=quota,
pay=pay_vec,
premium=premium,
method="L-BFGS-B",
lower=0,
upper=effort_max)
effort_choice<-obj$par
e_harvest<-map_dbl(.x=w_grid,
.f=~harvest_function(effort=effort_choice,
biomass=b,
quota=quota,
shock=.x))
esc<-map2_dbl(.x=e_harvest,.y=w_grid,~max((1+.y)*b-.x,biomass_min))
xnext<-map_dbl(esc,~growth(.x))
temp<-map_dbl(xnext,~spline(x=biomass_grid,y=V_now,xout=.x,method='natural')$y)
pay<-pay_vec
pi<-e_harvest-c_cost*effort_choice^2+pay-premium
e_ut<-map_dbl(.x=pi,
.f=~utility(c=.x,gamma=gamma,boost=0,mod='cara'))*w_probs
if(alpha==1){
return(-(sum(e_harvest*w_probs)+beta*sum(temp*w_probs)))
} else if(alpha==0){
return(-((1-alpha)*sum(e_ut)+beta*sum(temp*w_probs)))
} else{
scale=max_ut/max_harvest # Make sure we have a more equal comparison between harvest and ut
return(-(alpha*sum(e_harvest*w_probs)*scale+(1-alpha)*sum(e_ut)+beta*sum(temp*w_probs)))
}
}
DFall = data.frame()
Vnext = vector(mode='numeric',length=n_biomass)
V = rep(0,length.out=n_biomass)
pol_converged=vector(mode='numeric',length=n_biomass) #Harvest Policy function
polnow=vector(mode='numeric',length=n_biomass)
step=1
error="False"
tol=0.01
while(error=="False"){
t=step
#Loop over shocks space
for(i in 1:n_biomass){
b=biomass_grid[i]
guess=b/10
#output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
output = optim(par=guess,
fn=objective_fcn,
lower=0.00001,
upper=b,
b=b,
V_now=V,
pay_vec=pay,
premium=premium,
method='Brent')
#output = optim(par=guess,fn=objective_fcn,lower=0.00001,upper=K,b=b,V_now=V,pay_vec=pay,premium=premium,method='L-BFGS-B')
fstar = output$par
Vstar = -output$val
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
print(error_vec)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==200){
print('Maximum number of iterations (400) reached.')
break
}
}
polnow
Vnext
polnow
quota=64
obj<-optim(par=0.1,
fn=ut_max,
biomass=b,
quota=quota,
pay=pay_vec,
premium=premium,
method="L-BFGS-B",
lower=0,
upper=effort_max)
obj<-optim(par=0.1,
fn=ut_max,
biomass=b,
quota=quota,
pay=pay,
premium=premium,
method="L-BFGS-B",
lower=0,
upper=effort_max)
effort_choice<-obj$par
e_harvest<-map_dbl(.x=w_grid,
.f=~harvest_function(effort=effort_choice,
biomass=b,
quota=quota,
shock=.x))
e_harvest
esc<-map2_dbl(.x=e_harvest,.y=w_grid,~max((1+.y)*b-.x,biomass_min))
xnext<-map_dbl(esc,~growth(.x))
temp<-map_dbl(xnext,~spline(x=biomass_grid,y=V_now,xout=.x,method='natural')$y)
temp<-map_dbl(xnext,~spline(x=biomass_grid,y=V,xout=.x,method='natural')$y)
temp
pay
pi
e_ut<-map_dbl(.x=pi,
.f=~utility(c=.x,gamma=gamma,boost=0,mod='cara'))*w_probs
e_ut
e_ut<-map_dbl(.x=pi,
.f=~utility(c=.x,gamma=gamma,boost=0,mod='cara'))
e_ut
e_ut*w_probs
sum(e_ut*w_probs)
Vnext
polnow
Vnext
polnow
biomass_grid
Vnext
objective_fcn<-function(choice,b,V_now,pay_vec,premium){
quota<-choice[1]
obj<-optim(par=0.1,
fn=ut_max,
biomass=b,
quota=quota,
pay=pay_vec,
premium=premium,
method="L-BFGS-B",
lower=0,
upper=effort_max)
effort_choice<-obj$par
e_harvest<-map_dbl(.x=w_grid,
.f=~harvest_function(effort=effort_choice,
biomass=b,
quota=quota,
shock=.x))
esc<-map2_dbl(.x=e_harvest,.y=w_grid,~max((1+.y)*b-.x,biomass_min))
xnext<-map_dbl(esc,~growth(.x))
temp<-map_dbl(xnext,~spline(x=biomass_grid,y=V_now,xout=.x,method='natural')$y)
pay<-pay_vec
pi<-e_harvest-c_cost*effort_choice^2+pay-premium
e_ut<-map_dbl(.x=pi,
.f=~utility(c=.x,gamma=gamma,boost=0,mod='cara'))*w_probs
if(alpha==1){
return(-(sum(e_harvest*w_probs)+beta*sum(temp*w_probs)))
} else if(alpha==0){
return(-((1-alpha)*sum(e_ut)+beta*sum(temp*w_probs)))
} else{
scale=max_ut/max_harvest # Make sure we have a more equal comparison between harvest and ut
return(-(alpha*sum(e_harvest*w_probs)*scale+(1-alpha)*sum(e_ut)+beta*sum(temp*w_probs)))
}
}
DFall = data.frame()
Vnext = vector(mode='numeric',length=n_biomass)
V = rep(0,length.out=n_biomass)
pol_converged=vector(mode='numeric',length=n_biomass) #Harvest Policy function
polnow=vector(mode='numeric',length=n_biomass)
step=1
error="False"
tol=0.01
while(error=="False"){
t=step
#Loop over shocks space
for(i in 1:n_biomass){
b=biomass_grid[i]
guess=b/10
#output = nloptr(x0=guess,eval_f=Payoff_pre,lb=0.0001,ub=1,opts=options,b=b,V=V,sim=sim,r=r,K=K,delta=delta,ra=a,ut_mod=ut_mod,xgrid=xgrid,p=p,c=c,cshape=cshape,trigger=trigger,premium=premium,gamma=gamma)
output = optim(par=guess,
fn=objective_fcn,
lower=0.00001,
upper=b,
b=b,
V_now=V,
pay_vec=pay,
premium=premium,
method='Brent')
#output = optim(par=guess,fn=objective_fcn,lower=0.00001,upper=K,b=b,V_now=V,pay_vec=pay,premium=premium,method='L-BFGS-B')
fstar = output$par
Vstar = -output$val
Vnext[i]=Vstar
DFnow = data.frame(time=t,b=b,fstar=fstar,Vstar=Vstar)
DFall = bind_rows(DFall,DFnow)
polnow[i]=fstar
}
#Check if errors reach tolerance for policy function convergence
comp<-abs(polnow-pol_converged)
error_vec<-mean(comp)
print(error_vec)
if(error_vec<tol & step>9){
error="True"
}else{
error="False"
}
step=step+1
#browser()
V=Vnext
pol_converged=polnow
#Check to make sure we stop eventually
if(step==200){
print('Maximum number of iterations (400) reached.')
break
}
}
conv<-DFall |>
filter(time==max(DFall$time)) |>
select(-time)
View(conv)
